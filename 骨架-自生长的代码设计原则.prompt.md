#### 目标
生成一份遵循“渐进暴露”和“模块内生”设计哲学的代码。代码本身应如同一篇结构清晰、自上而下、流畅易读的叙事文章。

#### 核心指令
请为我编写一个**单一、完整的代码文件**，用于完成以下任务：
**`[在这里详细描述你的具体编程任务，例如：编写一个从API获取天气数据并生成摘要文本的程序]`**

请使用 **`[在这里指定编程语言，例如：Python]`** 来实现。

生成的代码必须严格遵守以下**四大核心原则**：

1.  **原则一：自上而下的叙事结构 (Top-Down Narrative)**
    *   代码文件的物理布局必须从最高层次的抽象（程序的入口和主流程）开始。
    *   读者应能通过从上到下的顺序阅读，就能像读文章目录一样，先理解程序的整体“骨架”和意图，然后再深入到具体实现细节。

2.  **原则二：渐进式暴露复杂性 (Progressive Disclosure)**
    *   隐藏实现细节，只在必要时才揭示。
    *   高层级的公共方法（如 `process()`）应该非常简洁，其本身只作为调用一系列私有辅助方法的“协调者”。
    *   避免让读者在理解核心流程时，过早地陷入细节的泥潭，从而降低心智负担。

3.  **原则三：模块的“内部生长” (Internal Growth)**
    *   功能逻辑应该在“模块内部”有机地生长出来，而不是随意散落在各处。
    *   **关键要求**：任何实现细节的私有/辅助函数，都应该被定义在**紧随其调用者之后**的位置。这使得相关逻辑高度内聚，形成一个自洽的“功能块”，方便读者在理解一个概念后，立刻看到它的实现。

4.  **原则四：流畅的阅读体验 (Fluent Readability)**
    *   代码的物理顺序应与核心的逻辑执行顺序保持高度一致。
    *   最大限度地减少读者为了理解一个完整功能而需要在文件中进行“代码跳转”的次数。整个阅读过程应如行云流水，自然顺畅。

#### 产出要求
*   **单一文件**：所有代码都在一个文件中。
*   **清晰的入口**：代码的开头部分应明确展示程序的入口（例如 `main()` 函数）。
*   **叙事性注释**：使用注释作为“章节标题”或“旁白”，来引导读者理解代码的结构和设计意图。
*   **高内聚实现**：私有辅助方法和调用它们的公共方法物理上要紧密相邻。
*   **VSCODE兼容**：注释标题前使用 `region ` 关键字来标注代码区域。

下面是一个遵循这种理念精心编写的 Python 示例。

---

### 示例：一份“自生长的”数据报告生成器

这份代码的使命是：读取原始销售数据，进行清洗和分析，最后生成一份人类可读的文本报告。

请注意代码的**组织顺序**，它就是为了实现您所描述的阅读体验而设计的。

```python
# report_generator.py
# 这份代码文件本身就是一篇“说明文”，从上到下阅读，即可理解整个项目的结构和细节。

import json
from pathlib import Path
from datetime import datetime
from collections import Counter

# ==============================================================================
# region 序章：程序的入口 (The Entry Point)
# 我们从最高层次的抽象开始：程序的“主函数”。
# 它清晰地表明了我们的意图：创建一个报告生成器并运行它。
# ==============================================================================

def main():
    """程序的最高层抽象和入口。"""
    print("开始生成销售报告...")
    try:
        # 1. 初始化：传入配置文件路径，建立上下文。
        generator = SalesReportGenerator("config.json")
        # 2. 执行：调用核心方法，完成所有工作。
        generator.generate_report()
        print("报告生成成功！")
    except Exception as e:
        print(f"错误：报告生成失败。原因: {e}")

# ==============================================================================
# region 第一章：核心骨架 - SalesReportGenerator 类 (The Core Skeleton)
# 这是我们故事的主体。类本身定义了核心流程 `generate_report`。
# 这个方法就像是书的目录，列出了所有主要步骤，但隐藏了每个步骤的复杂细节。
# 这是“骨架从模糊到清晰”的第一步：一个清晰的、高层次的骨架。
# ==============================================================================

class SalesReportGenerator:
    """负责加载、分析和生成销售报告的核心类。"""

    def __init__(self, config_path: str):
        """
        构造函数：仅负责最基本的初始化，加载配置。
        复杂性被委托给一个私有方法，保持构造函数的简洁。
        """
        self._config = self._load_config(config_path)
        self._raw_data = None
        self._analysis_result = None

    def generate_report(self):
        """
        核心流程方法，定义了报告生成的完整步骤。
        这是一个清晰的“骨架”，逻辑顺序与执行顺序完全一致。
        """
        # 步骤 1: 加载数据
        self._load_source_data()
        
        # 步骤 2: 分析数据
        self._analyze_data()
        
        # 步骤 3: 生成报告
        self._create_report_file()

    # --------------------------------------------------------------------------
    # region 章节 1.1: 模块内生 - 加载配置 (Internal Growth: Configuration)
    # `__init__` 的具体实现。我们在这里“生长”出配置加载的细节。
    # --------------------------------------------------------------------------
    
    def _load_config(self, path: str) -> dict:
        """从文件加载配置，如果失败则使用默认值。"""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"警告：配置文件 '{path}' 未找到，将使用默认配置。")
            return {
                "source_file": "data/sales.json",
                "report_file": "output/report.txt",
                "top_n_products": 3
            }

    # --------------------------------------------------------------------------
    # region 章节 1.2: 模块内生 - 加载源数据 (Internal Growth: Data Loading)
    # `generate_report` 第一步的具体实现。
    # --------------------------------------------------------------------------

    def _load_source_data(self):
        """根据配置加载原始销售数据。"""
        source_path = self._config['source_file']
        print(f"  - 正在从 '{source_path}' 加载数据...")
        
        if not Path(source_path).exists():
            raise FileNotFoundError(f"源文件 '{source_path}' 不存在。")
            
        with open(source_path, 'r', encoding='utf-8') as f:
            self._raw_data = json.load(f)
        
        if not self._raw_data:
            raise ValueError("源数据为空或格式不正确。")

    # --------------------------------------------------------------------------
    # region 章节 1.3: 模块内生 - 分析数据 (Internal Growth: Data Analysis)
    # `generate_report` 第二步的具体实现。
    # 这个模块本身也包含更细粒度的“内部生长”。
    # --------------------------------------------------------------------------

    def _analyze_data(self):
        """对加载的原始数据进行核心分析。"""
        print("  - 正在分析数据...")
        total_revenue = self._calculate_total_revenue()
        product_sales = self._count_product_sales()
        top_products = product_sales.most_common(self._config['top_n_products'])
        
        self._analysis_result = {
            "total_revenue": total_revenue,
            "top_selling_products": top_products
        }

    def _calculate_total_revenue(self) -> float:
        """内部辅助函数：计算总收入。"""
        return sum(item['price'] * item['quantity'] for item in self._raw_data)

    def _count_product_sales(self) -> Counter:
        """内部辅助函数：统计各产品销量。"""
        return Counter(item['product_name'] for item in self._raw_data)

    # --------------------------------------------------------------------------
    # region 章节 1.4: 模块内生 - 创建报告文件 (Internal Growth: Report Creation)
    # `generate_report` 第三步的具体实现。
    # --------------------------------------------------------------------------

    def _create_report_file(self):
        """将分析结果格式化并写入文本文件。"""
        report_path_str = self._config['report_file']
        print(f"  - 正在生成报告到 '{report_path_str}'...")
        
        report_content = self._format_report_content()
        
        # 确保输出目录存在
        Path(report_path_str).parent.mkdir(parents=True, exist_ok=True)
        
        with open(report_path_str, 'w', encoding='utf-8') as f:
            f.write(report_content)

    def _format_report_content(self) -> str:
        """内部辅助函数：将分析结果格式化为字符串。"""
        res = self._analysis_result
        top_products_str = "\n".join(
            f"    - {name}: {count} 件" for name, count in res['top_selling_products']
        )

        return f"""
销售分析报告
==================================
报告生成时间: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
----------------------------------

总销售额: ${res['total_revenue']:.2f}

销量最高的产品 (Top {self._config['top_n_products']}):
{top_products_str}

==================================
"""

# ==============================================================================
# region 尾声：启动程序 (The Execution Trigger)
# 遵循 Python 的最佳实践，将 `main()` 的调用放在这里。
# 这是读者在文件中看到的最后一件事，自然地完成了整个阅读流程。
# ==============================================================================

if __name__ == "__main__":
    main()

```

### 这份代码如何体现您的理念？

1.  **自上而下的阅读体验**：
    *   你首先看到 `main()`，立即明白程序的入口和目标。
    *   接着是 `SalesReportGenerator` 类和它的核心方法 `generate_report()`，这是整个故事的“大纲”。
    *   然后，代码按照 `generate_report()` 中声明的顺序，依次展开每个私有方法的实现 (`_load_config`, `_load_source_data`, `_analyze_data` ...)。你不需要跳来跳去，只需顺序阅读。

2.  **骨架进化与渐进暴露 (Progressive Disclosure)**：
    *   **骨架**：`generate_report` 方法本身就是一个清晰、高级的骨架。
    *   **渐进暴露**：当你读到 `_analyze_data()` 时，你看到了它的子步骤：计算总收入、统计销量等。但这些子步骤的实现又被委托给了更小的辅助函数 `_calculate_total_revenue()` 和 `_count_product_sales()`。复杂性被一层层地揭开，而不是一次性全部抛给你。

3.  **模块内生 (Internal Growth)**：
    *   **`_analyze_data` 模块**：它不仅仅是一个函数，它是一个包含`_calculate_total_revenue`和`_count_product_sales`的微型生态系统。这些功能在 `_analyze_data` 的“内部”生长出来，服务于它，并且不被外界所知。
    *   **从左到右的最小可用单元**：在 `_analyze_data` 内部，我们先计算 `total_revenue`（一个可用的中间结果），然后计算 `product_sales`（另一个可用的中间结果），最后组合它们。每一步都产出有意义的上下文，并为下一步做准备。

4.  **减少心智负担**：
    *   由于实现细节（私有方法）紧跟在调用它的高层方法之后，你的短期记忆负担非常小。
    *   当你在阅读 `generate_report` 时，你不需要关心 `_load_source_data` 是如何处理 `FileNotFoundError` 的。如果你关心，答案就在下面几行，你不需要去文件的另一个遥远的地方寻找。

这种写法将代码从单纯的“指令集合”提升为一种“结构化的叙事”，极大地增强了可读性和可维护性。

---

### 如何使用这个模板

您只需要替换 `[...]` 中的内容即可。

**使用示例：**

> 请为我编写一个**单一、完整的代码文件**，用于完成以下任务：
> **编写一个Python脚本，它读取一个名为 `tasks.csv` 的文件（包含'任务名称', '优先级', '截止日期'三列），然后筛选出所有“高”优先级的任务，并将其格式化后输出到一个名为 `urgent_tasks.txt` 的文本文件中。**
>
> 请使用 **Python** 来实现。
>
> 生成的代码必须严格遵守以下**四大核心原则**：
>
> 1.  **原则一：自上而下的叙事结构...**
> 2.  **原则二：渐进式暴露复杂性...**
> 3.  **原则三：模块的“内部生长”...**
> 4.  **原则四：流畅的阅读体验...**
>
> ...（后面原则的详细描述保持不变）
